---
title: "Timing in R"
author: "Theo Roe"
date: 2017-10-24
output: html_document
draft: true
slug: "timing_in_R"
tags: [r, timing, microbenchmark, tictoc, System.time]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

As time goes on, your R scripts are probably getting longer and more complicated, _right_? Timing parts of your script could save you precious time when re-running code over and over again. Today I'm going ot go through the 4 main functions for doing so. 

***

## Nested Timing

### 1) `Sys.time()`

`Sys.time()` takes a "screenshot"" of the current time and so it can be used to record start and end times of code.

```{r}
start_time = Sys.time()
Sys.sleep(0.5)
end_time = Sys.time()

time_dif = end_time - start_time
time_dif
```

Notice it creates a neat little message for the time difference.

### 2) The tictoc Package

You can install the `CRAN` version of __tictoc__ via 
```{r, eval = FALSE}
install.packages("tictoc")
```
whilst the most recent development is available via github
```{r, eval = FALSE}
devtools::install_github("collectivemedia/tictoc")
``` 
```{r}
library(tictoc)
```

Like `Sys.time()`, __tictoc__ also gives us ability to nest timings within code. However, we now have some more options to customise our timing. At it's most basic it acts like `Sys.time()`:
```{r}
tic()
Sys.sleep(0.5)
toc()
```

Now for a more contrived example. 
```{r}
# start timer for the entire section, notice we can name sections of code
tic("total time") 
# start timer for first subsection
tic("Start time til half way")
Sys.sleep(2)
# end timer for the first subsection, log = TRUE tells toc to give us a message
toc(log = TRUE)
# start timer for second subsection
tic("Half way til end")
Sys.sleep(2)
# end timer for second subsection
toc(log = TRUE)
# end timer for entire section
toc(log = TRUE)
# log results as a list, format = TRUE returns this list in a nice format, rather than raw code
timing = tic.log(format=TRUE)
timing
# clear the log, if the log is not cleared then the next log would contain the results of the previous log
tic.clearlog()
```

I think returning the timings as a list is pretty cool. Not to mention how easy it is to do so. 

***

## Timing to Compare

### 1) `system.time()`

Why oh WHY did the guys over at R choose to give `system.time()` a lower case `s` and `Sys.time()` and upper case `s`? `r emo::ji("angry")`

Anyway...

`system.time()` can be used to time functions without having to take note of the start and end times. 
```{r}
system.time(Sys.sleep(0.5))
system.time(Sys.sleep(1))
```
We only want to take notice of the "elapsed" time, for the definition of the "user" and "system" times see [this thread.](http://r.789695.n4.nabble.com/Meaning-of-proc-time-td2303263.html#a2306691) 

For a repeated timing, we would use the `replicate()` function. 
```{r}
system.time(replicate(10, Sys.sleep(0.1)))
```

### 2) The microbenchmark Package

You can install the `CRAN` version of __microbenchmark__ via
```{r, eval = FALSE}
install.packages("microbenchmark")
```
Alternatively you can install the latest update via github
```{r, eval = FALSE}
devtools::install_github("olafmersmann/microbenchmarkCore")
devtools::install_github("olafmersmann/microbenchmark")
```
```{r}
library(microbenchmark)
```

At it's most basic, `microbenchmark()` can we used to time single pieces of code.

```{r}
microbenchmark(Sys.sleep(0.1), times = 10, unit = "s")
# times = 10 tells microbenchmark to repeat the test 10 times
# unit = "s" tells microbenchmark to return the output in seconds
```

Notice we get a nicely formatted table of summary statistics. We can record our times in anything from seconds to nanoseconds(!!!!). Already this is better than `system.time()`. Not only that, but we can compare sections of code in an easy-to-do way and name the sections of code for an easy-to-read output. 

```{r}
sleep = microbenchmark(sleepy = Sys.sleep(0.1), 
                       sleepier = Sys.sleep(0.2),
                       sleepiest = Sys.sleep(0.3),
                   times = 10, unit = "s")

```

As well as this (more?!) __microbenchmark__ comes with a two built-in plotting functions.

```{r}
microbenchmark:::autoplot.microbenchmark(sleep)
microbenchmark:::boxplot.microbenchmark(sleep)
```

These provide quick and efficient ways of visualising our timings. 

***

## Conclusion

`Sys.time()` and `system.time()` are long gone! For me, the __tictoc__ and __microbenchmark__ packages are far superior. In both packages, it is very easy to store the timings for later use, and the range of options for both packages stretch far past the options for `Sys.time()` and `system.time()`. I also _think_ that __microbenchmark__ is the only benchmarking package that has visualizations built in. OK, so they might not be the prettiest, but for a quick look at your timings, they provide a perfect service. 

Thanks for chatting!
