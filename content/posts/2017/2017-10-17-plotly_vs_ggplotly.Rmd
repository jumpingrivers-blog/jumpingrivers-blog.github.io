---
title: "plotly vs ggplot2"
author: "Theo Roe"
date: 2017-10-17
output: html_document
draft: true
slug: "plotly_vs_ggplotly"
tags: [r,tidyverse, graphics, ggplot2, plotly]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
library(mosaicData)
library(dplyr)
library(ggplot2)
library(plotly)
library(microbenchmark)
```


The __plotly__ package. A godsend for interactive documents, dashboard and presentations. For such documents there is no doubt that anyone would prefer a plot created in __plotly__ rather than __ggplot2__. Why? Using __plotly__ gives you neat and crucially _interactive_ options at the top, where as __ggplot2__ objects are static. In an app we have been devloping here at [Jumping Rivers](https://www.jumpingrivers.com), we found ourselves asking the question would it be quicker to use `plot_ly()` or wrapping a __ggplot2__ object in `ggplotly()`? I found the results staggering.   

### Prerequisites 

Throughout we will be using the packages: __dplyr__, __ggplot2__, __plotly__ and __microbenchmark__. The data in use is the `birthdays` dataset in the __mosaicData__ package. Containing the counts of births in USA on each day from 1969 - 1988.

```{r, eval = FALSE, message=FALSE, warning=FALSE}
install.packages("mosaicData")
library(mosaicData)
install.packages("dplyr")
library(dplyr)
install.packages("ggplot2")
library(ggplot2)
install.packages("plotly")
library(plotly)
install.packages("microbenchmark")
library(microbenchmark)
```

### Analysis
Let's take a look at the data.
```{r}
b = mosaicData::Birthdays
head(b)
```

Let's start off with a very simple scatter graph of the mean births in every year. 

```{r}
meanb = b %>% group_by(year) %>% summarise(mean = mean(births))
```

```{r, warning = FALSE, error=FALSE, message=FALSE}
ggplotly(ggplot(meanb) + 
  geom_point(aes(y = mean, x = year, colour = year)))

plot_ly(data = meanb, 
                 y = ~mean, x = ~year, color = ~year, 
                 type = "scatter")
```

Both graphs identical bar styling, yes? 

Now let's use `microbenchmark` to see how their timings compare. 

```{r, warning = FALSE, error=FALSE, message=FALSE}
time = microbenchmark::microbenchmark(
        ggplotly = ggplotly(ggplot(meanb) + 
                            geom_point(aes(y = mean, x = year, colour = year))),
          plotly = plot_ly(data = meanb, 
                           y = ~births, x = ~year, 
                           color = ~year, type = "scatter"),
                           times = 100, unit = "s")
time
```
```{r, warning = FALSE, error=FALSE, message=FALSE}
autoplot(time)
```

```{r, include=FALSE}
timetable = cbind(expr = time$expr, time = time$time)
mean = as.data.frame(timetable) %>% group_by(expr) %>% summarise(mean = mean(time))
average = round(mean[1,2]/mean[2,2], 0)
```
Now I thought nesting a __ggplot__ object within `ggplotly()` would be slower than using `plot_ly()`, but I didn't think it would be this slow. On average `ggplotly()` is `r average` times slower than `plot_ly()`. **_`r average`!_** One run even took `r round(microbenchmark:::convert_to_unit(max(time$time), unit = "s"), 3)` seconds! 

Let's take it up a notch.  There we were just plotting 20 points, what about if we plot over 20,000? Here we will plot the min, mean and max births on each day. 

```{r warning = FALSE, error=FALSE, message=FALSE}
meandate = b %>% group_by(date) %>% summarise(births = mean(births))
maxdate = b %>% group_by(date) %>% summarise(births = max(births))
mindate = b %>% group_by(date) %>% summarise(births = min(births))
all = rbind(meandate, maxdate, mindate)

all$stat = rep(c("mean","max", "min"), each = 7305)

ggplotly(ggplot(all) + geom_point(aes(y = births, x = date, colour = stat)))

plot_ly(all, x = ~date, y = ~births, color = ~stat, type = "scatter")
```
Again, both plots are identical bar styling.
```{r warning = FALSE, error=FALSE, message=FALSE}
time2 = microbenchmark(ggplotly = 
                                  ggplotly(ggplot(all) +
                                          geom_point(aes(y = births, x = date, colour = stat))),
                                 plotly = plot_ly(all, x = ~date, y = ~births, 
                                           color = ~stat, type = "scatter"),
                                   times = 100, unit = "s")
time2
```
```{r, warning = FALSE, error=FALSE, message=FALSE}
autoplot(time2)
```

```{r, include=FALSE}
timetable2 = cbind(expr = time2$expr, time = time2$time)
mean2 = as.data.frame(timetable2) %>% group_by(expr) %>% summarise(mean = mean(time))
average2 = round(mean2[1,2]/mean2[2,2], 0)
```

On average `ggplotly()` is `r average2` times slower than `plot_ly()`, with the max run time being `r round(microbenchmark:::convert_to_unit(max(time2$time), unit = "s"), 3)` seconds! 
