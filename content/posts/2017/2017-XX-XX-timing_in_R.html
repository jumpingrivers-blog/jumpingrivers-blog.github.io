---
title: "Timing in R"
author: "Theo Roe"
date: 2017-10-24
output: html_document
draft: true
slug: "timing-in-R"
tags: [r, timing, microbenchmark, tictoc, system-time]
---


<div id="TOC">
<ul>
<li><a href="#nested-timing">Nested Timing</a><ul>
<li><a href="#sys.time">1) <code>Sys.time()</code></a></li>
<li><a href="#the-tictoc-package">2) The tictoc Package</a></li>
</ul></li>
<li><a href="#timing-to-compare">Timing to Compare</a><ul>
<li><a href="#system.time">1) <code>system.time()</code></a></li>
<li><a href="#the-microbenchmark-package">2) The microbenchmark Package</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>

<p>As time goes on, your R scripts are probably getting longer and more complicated, <em>right</em>? Timing parts of your script could save you precious time when re-running code over and over again. Today I’m going ot go through the 4 main functions for doing so.</p>
<hr />
<div id="nested-timing" class="section level2">
<h2>Nested Timing</h2>
<div id="sys.time" class="section level3">
<h3>1) <code>Sys.time()</code></h3>
<p><code>Sys.time()</code> takes a “snap-shot” of the current time and so it can be used to record start and end times of code.</p>
<pre class="r"><code>start_time = Sys.time()
Sys.sleep(0.5)
end_time = Sys.time()

end_time - start_time
## Time difference of 0.5029 secs</code></pre>
<p>Notice it creates a neat little message for the time difference.</p>
</div>
<div id="the-tictoc-package" class="section level3">
<h3>2) The tictoc Package</h3>
<p>You can install the <code>CRAN</code> version of <strong>tictoc</strong> via</p>
<pre class="r"><code>install.packages(&quot;tictoc&quot;)</code></pre>
<p>whilst the most recent development is available via <a href="https://github.com/collectivemedia/tictoc">the <strong>tictoc</strong> GitHub page</a>.</p>
<pre class="r"><code>library(&quot;tictoc&quot;)</code></pre>
<p>Like <code>Sys.time()</code>, <strong>tictoc</strong> also gives us ability to nest timings within code. However, we now have some more options to customise our timing. At it’s most basic it acts like <code>Sys.time()</code>:</p>
<pre class="r"><code>tic()
Sys.sleep(0.5)
toc()
## 0.504 sec elapsed</code></pre>
<p>Now for a more contrived example.</p>
<pre class="r"><code># start timer for the entire section, notice we can name sections of code
tic(&quot;total time&quot;) 
# start timer for first subsection
tic(&quot;Start time til half way&quot;)
Sys.sleep(2)
# end timer for the first subsection, log = TRUE tells toc to give us a message
toc(log = TRUE)
## Start time til half way: 2.028 sec elapsed
# start timer for second subsection
tic(&quot;Half way til end&quot;)
Sys.sleep(2)
# end timer for second subsection
toc(log = TRUE)
## Half way til end: 2.005 sec elapsed
# end timer for entire section
toc(log = TRUE)
## total time: 4.038 sec elapsed
# log results as a list, format = TRUE returns this list in a nice format, rather than raw code
timing = tic.log(format=TRUE)
timing
## [[1]]
## [1] &quot;Start time til half way: 2.028 sec elapsed&quot;
## 
## [[2]]
## [1] &quot;Half way til end: 2.005 sec elapsed&quot;
## 
## [[3]]
## [1] &quot;total time: 4.038 sec elapsed&quot;
# clear the log, if the log is not cleared then the next log would contain the results of the previous log
tic.clearlog()</code></pre>
<p>I think returning the timings as a list is pretty cool. Not to mention how easy it is to do so.</p>
<hr />
</div>
</div>
<div id="timing-to-compare" class="section level2">
<h2>Timing to Compare</h2>
<div id="system.time" class="section level3">
<h3>1) <code>system.time()</code></h3>
<p>Why oh WHY did the guys over at R choose to give <code>system.time()</code> a lower case <code>s</code> and <code>Sys.time()</code> and upper case <code>s</code>?</p>
<p>Anyway…</p>
<p><code>system.time()</code> can be used to time functions without having to take note of the start and end times.</p>
<pre class="r"><code>system.time(Sys.sleep(0.5))
##    user  system elapsed 
##     0.0     0.0     0.5
system.time(Sys.sleep(1))
##    user  system elapsed 
##   0.000   0.000   1.001</code></pre>
<p>We only want to take notice of the “elapsed” time, for the definition of the “user” and “system” times see <a href="http://r.789695.n4.nabble.com/Meaning-of-proc-time-td2303263.html#a2306691">this thread.</a></p>
<p>For a repeated timing, we would use the <code>replicate()</code> function.</p>
<pre class="r"><code>system.time(replicate(10, Sys.sleep(0.1)))
##    user  system elapsed 
##   0.000   0.000   1.003</code></pre>
</div>
<div id="the-microbenchmark-package" class="section level3">
<h3>2) The microbenchmark Package</h3>
<p>You can install the <code>CRAN</code> version of <strong>microbenchmark</strong> via</p>
<pre class="r"><code>install.packages(&quot;microbenchmark&quot;)</code></pre>
<p>Alternatively you can install the latest update via <a href="https://github.com/olafmersmann/microbenchmark">the <strong>microbenchmark</strong> GitHub page.</a></p>
<pre class="r"><code>library(&quot;microbenchmark&quot;)</code></pre>
<p>At it’s most basic, <code>microbenchmark()</code> can we used to time single pieces of code.</p>
<pre class="r"><code>microbenchmark(Sys.sleep(0.1), times = 10, unit = &quot;s&quot;)
## Unit: seconds
##            expr    min     lq   mean median     uq    max neval
##  Sys.sleep(0.1) 0.1001 0.1002 0.1002 0.1002 0.1002 0.1002    10
# times = 10 tells microbenchmark to repeat the test 10 times
# unit = &quot;s&quot; tells microbenchmark to return the output in seconds</code></pre>
<p>Notice we get a nicely formatted table of summary statistics. We can record our times in anything from seconds to nanoseconds(!!!!). Already this is better than <code>system.time()</code>. Not only that, but we can compare sections of code in an easy-to-do way and name the sections of code for an easy-to-read output.</p>
<pre class="r"><code>sleep = microbenchmark(sleepy = Sys.sleep(0.1), 
                       sleepier = Sys.sleep(0.2),
                       sleepiest = Sys.sleep(0.3),
                   times = 10, unit = &quot;s&quot;)</code></pre>
<p>As well as this (more?!) <strong>microbenchmark</strong> comes with a two built-in plotting functions.</p>
<pre class="r"><code>microbenchmark:::autoplot.microbenchmark(sleep)</code></pre>
<p><img src="/posts/2017/2017-XX-XX-timing_in_R_files/figure-html/unnamed-chunk-12-1.svg" width="576" /></p>
<pre class="r"><code>microbenchmark:::boxplot.microbenchmark(sleep)</code></pre>
<p><img src="/posts/2017/2017-XX-XX-timing_in_R_files/figure-html/unnamed-chunk-12-2.svg" width="576" /></p>
<p>These provide quick and efficient ways of visualising our timings.</p>
<hr />
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p><code>Sys.time()</code> and <code>system.time()</code> are long gone! For me, the <strong>tictoc</strong> and <strong>microbenchmark</strong> packages are far superior. In both packages, it is very easy to store the timings for later use, and the range of options for both packages stretch far past the options for <code>Sys.time()</code> and <code>system.time()</code>. I also <em>think</em> that <strong>microbenchmark</strong> is the only benchmarking package that has visualizations built in. OK, so they might not be the prettiest, but for a quick look at your timings, they provide a perfect service.</p>
<p>Thanks for chatting!</p>
</div>
